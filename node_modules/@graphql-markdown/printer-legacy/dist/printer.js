"use strict";
/**
 * GraphQL Schema Printer Module
 *
 * This module provides functionality for printing GraphQL schema types into Markdown documentation.
 * It includes utilities for handling various GraphQL types, custom directives, and formatting options.
 *
 * @module printer
 * @packageDocumentation
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Printer = void 0;
const graphql_1 = require("@graphql-markdown/graphql");
const utils_1 = require("@graphql-markdown/utils");
const relation_1 = require("./relation");
const common_1 = require("./common");
const directive_1 = require("./directive");
const frontmatter_1 = require("./frontmatter");
const graphql_2 = require("./graphql");
const link_1 = require("./link");
const strings_1 = require("./const/strings");
const mdx_1 = require("./mdx");
const options_1 = require("./const/options");
const example_1 = require("./example");
/**
 * The Printer class implements the core functionality for generating Markdown documentation
 * from GraphQL schema types.
 *
 * @remarks
 * This class provides static methods for rendering different components of the documentation:
 * - Headers and frontmatter
 * - Type descriptions and code blocks
 * - Custom directives and metadata
 * - Examples and relations
 *
 * @example
 * ```typescript
 * const printer = new Printer();
 * await printer.init(schema, '/docs', 'graphql', options);
 * const docs = printer.printType('Query', queryType);
 * ```
 */
class Printer {
    /**
     * Global printer configuration options
     * @static
     */
    static options;
    /**
     * Prints type descriptions
     * @static
     */
    static printDescription = common_1.printDescription;
    /**
     * Prints custom directives
     * @static
     */
    static printCustomDirectives = directive_1.printCustomDirectives;
    /**
     * Prints custom tags
     * @static
     */
    static printCustomTags = directive_1.printCustomTags;
    /**
     * MDX module configuration
     * @static
     */
    static printMDXModule;
    /**
     * Initializes the printer with the given schema and configuration.
     *
     * @param schema - GraphQL schema to generate documentation for
     * @param baseURL - Base URL path for documentation, e.g. '/docs'
     * @param linkRoot - Root path for generating links between types
     * @param options - Configuration options for the printer
     * @param mdxParser - Optional MDX parser module for MDX output support
     */
    static async init(schema, baseURL = "schema", linkRoot = "/", { customDirectives, groups, meta, metatags, onlyDocDirectives, printTypeOptions, skipDocDirectives, } = {
        customDirectives: undefined,
        groups: undefined,
    }, mdxParser) {
        if (typeof Printer.options !== "undefined") {
            return;
        }
        Printer.options = {
            ...options_1.DEFAULT_OPTIONS,
            basePath: utils_1.pathUrl.join(linkRoot ?? "", baseURL ?? ""),
            codeSection: printTypeOptions?.codeSection ?? options_1.PRINT_TYPE_DEFAULT_OPTIONS.codeSection,
            customDirectives,
            exampleSection: printTypeOptions?.exampleSection ??
                options_1.PRINT_TYPE_DEFAULT_OPTIONS.exampleSection,
            groups,
            parentTypePrefix: printTypeOptions?.parentTypePrefix ??
                options_1.PRINT_TYPE_DEFAULT_OPTIONS.parentTypePrefix,
            deprecated: printTypeOptions?.deprecated ?? options_1.PRINT_TYPE_DEFAULT_OPTIONS.deprecated,
            relatedTypeSection: printTypeOptions?.relatedTypeSection ??
                options_1.PRINT_TYPE_DEFAULT_OPTIONS.relatedTypeSection,
            schema,
            onlyDocDirectives: onlyDocDirectives ?? [],
            skipDocDirectives: skipDocDirectives ?? [],
            typeBadges: printTypeOptions?.typeBadges ?? options_1.PRINT_TYPE_DEFAULT_OPTIONS.typeBadges,
            metatags: metatags ?? [],
            hierarchy: printTypeOptions?.hierarchy ?? options_1.PRINT_TYPE_DEFAULT_OPTIONS.hierarchy,
            meta: meta,
        };
        Printer.printMDXModule = await (0, mdx_1.mdxModule)(mdxParser);
    }
    /**
     * Prints the header section of a type documentation
     *
     * @param id - Unique identifier for the type
     * @param title - Display title for the type
     * @param options - Printer configuration options
     * @returns Formatted header string with optional frontmatter
     */
    static printHeader = (id, title, options) => {
        if (options.frontMatter === false) {
            return `# ${title}${strings_1.MARKDOWN_EOP}`;
        }
        const fmOptions = options.frontMatter ?? options_1.DEFAULT_OPTIONS.frontMatter;
        return (0, frontmatter_1.printFrontMatter)(title, { ...fmOptions, id }, options);
    };
    /**
     * Prints the GraphQL type definition as code block
     *
     * @param type - GraphQL type to print
     * @param options - Printer configuration options
     * @returns Formatted code block string with type definition
     */
    static printCode = (type, options) => {
        let code = "";
        if (typeof options.codeSection === "undefined" ||
            options.codeSection !== true) {
            return code;
        }
        switch (true) {
            case (0, graphql_1.isOperation)(type):
                code += (0, graphql_2.printCodeOperation)(type, options);
                break;
            case (0, graphql_1.isEnumType)(type):
                code += (0, graphql_2.printCodeEnum)(type, options);
                break;
            case (0, graphql_1.isUnionType)(type):
                code += (0, graphql_2.printCodeUnion)(type, options);
                break;
            case (0, graphql_1.isInterfaceType)(type):
                code += (0, graphql_2.printCodeInterface)(type, options);
                break;
            case (0, graphql_1.isObjectType)(type):
                code += (0, graphql_2.printCodeObject)(type, options);
                break;
            case (0, graphql_1.isInputType)(type):
                code += (0, graphql_2.printCodeInput)(type, options);
                break;
            case (0, graphql_1.isScalarType)(type):
                code += (0, graphql_2.printCodeScalar)(type, options);
                break;
            case (0, graphql_1.isDirectiveType)(type):
                code += (0, graphql_2.printCodeDirective)(type, options);
                break;
            default:
                code += `"${(0, graphql_1.getTypeName)(type)}" not supported`;
        }
        return strings_1.MARKDOWN_SOC + code.trim() + strings_1.MARKDOWN_EOC;
    };
    /**
     * Prints example usage of the type if available
     *
     * @param type - GraphQL type to generate example for
     * @param options - Printer configuration options
     * @returns Formatted example section string or empty string if no example
     */
    static printExample = (type, options) => {
        if (typeof options.exampleSection === "undefined" ||
            options.exampleSection === null ||
            options.exampleSection === false) {
            return "";
        }
        const example = (0, example_1.printExample)(type, options);
        if (!example) {
            return "";
        }
        return `${options_1.SectionLevels.LEVEL.repeat(3)} Example${strings_1.MARKDOWN_EOP}${strings_1.MARKDOWN_SOC}${example}${strings_1.MARKDOWN_EOC}${strings_1.MARKDOWN_EOP}`;
    };
    /**
     * Prints metadata information for a GraphQL type
     *
     * @param type - GraphQL type to print metadata for
     * @param options - Printer configuration options
     * @returns Formatted metadata string as MDX or plain string
     * @throws {Error} When type is not supported
     */
    static printTypeMetadata = (type, options) => {
        switch (true) {
            case (0, graphql_1.isScalarType)(type):
                return (0, graphql_2.printScalarMetadata)(type, options);
            case (0, graphql_1.isEnumType)(type):
                return (0, graphql_2.printEnumMetadata)(type, options);
            case (0, graphql_1.isUnionType)(type):
                return (0, graphql_2.printUnionMetadata)(type, options);
            case (0, graphql_1.isObjectType)(type):
                return (0, graphql_2.printObjectMetadata)(type, options);
            case (0, graphql_1.isInterfaceType)(type):
                return (0, graphql_2.printInterfaceMetadata)(type, options);
            case (0, graphql_1.isInputType)(type):
                return (0, graphql_2.printInputMetadata)(type, options);
            case (0, graphql_1.isDirectiveType)(type):
                return (0, graphql_2.printDirectiveMetadata)(type, options);
            case (0, graphql_1.isOperation)(type):
                return (0, graphql_2.printOperationMetadata)(type, options);
            default:
                return "";
        }
    };
    /**
     * Prints related type information
     *
     * @param type - GraphQL type to find relations for
     * @param options - Printer configuration options
     * @returns Formatted relations section as MDX or plain string
     */
    static printRelations = (type, options) => {
        if (options.relatedTypeSection !== true) {
            return "";
        }
        return (0, relation_1.printRelations)(type, options);
    };
    /**
     * Prints HTML meta tags for the documentation
     *
     * @param _type - GraphQL type (unused)
     * @param options - Printer configuration options containing metatags
     * @returns Formatted HTML meta tags string
     */
    static printMetaTags = (_type, { metatags }) => {
        if (!metatags || metatags.length < 1) {
            return "";
        }
        const meta = metatags.map((tag) => {
            const props = Object.entries(tag).map(([name, value]) => {
                return `${name}="${value}"`;
            });
            return `<meta ${props.join(" ")} />`;
        });
        return ["<head>", ...meta, "</head>"].join(strings_1.MARKDOWN_EOL);
    };
    /**
     * Main method to print complete documentation for a GraphQL type
     *
     * @param name - Name identifier for the type
     * @param type - GraphQL type to generate documentation for
     * @param options - Optional printer configuration options
     * @returns Complete documentation as MDX string or undefined if type should be skipped
     *
     * @example
     * ```typescript
     * const doc = Printer.printType('User', UserType, {
     *   frontMatter: true,
     *   codeSection: true
     * });
     * ```
     *
     * @remarks
     * The method combines multiple sections:
     * - Header with frontmatter
     * - Meta tags
     * - Description
     * - Code definition
     * - Custom directives
     * - Type metadata
     * - Example usage
     * - Related types
     */
    static printType = (name, type, options) => {
        const printTypeOptions = {
            ...options_1.DEFAULT_OPTIONS,
            ...Printer.options,
            ...options,
            ...Printer.printMDXModule,
        };
        if (!name || !(0, link_1.hasPrintableDirective)(type, printTypeOptions)) {
            return undefined;
        }
        const header = Printer.printHeader(name, (0, graphql_1.getTypeName)(type), printTypeOptions);
        const metatags = Printer.printMetaTags(type, printTypeOptions);
        const description = Printer.printDescription(type, printTypeOptions);
        const code = Printer.printCode(type, printTypeOptions);
        const customDirectives = Printer.printCustomDirectives(type, printTypeOptions);
        const tags = Printer.printCustomTags(type, printTypeOptions);
        const metadata = Printer.printTypeMetadata(type, printTypeOptions);
        const relations = Printer.printRelations(type, printTypeOptions);
        const example = Printer.printExample(type, printTypeOptions);
        return [
            header,
            metatags,
            Printer.printMDXModule.mdxDeclaration,
            tags,
            description,
            code,
            customDirectives,
            metadata,
            example,
            relations,
        ]
            .join(strings_1.MARKDOWN_EOP)
            .trim();
    };
}
exports.Printer = Printer;
