"use strict";
/**
 * Provides utilities for handling and printing GraphQL directives in Markdown format
 * @module
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.printCustomTags = exports.getCustomTags = exports.printCustomDirectives = exports.printCustomDirective = exports.getCustomDirectiveResolver = void 0;
const graphql_1 = require("@graphql-markdown/graphql");
const strings_1 = require("./const/strings");
const options_1 = require("./const/options");
const link_1 = require("./link");
const badge_1 = require("./badge");
/**
 * Resolves a custom directive using the provided resolver function
 * @param resolver - The resolver function name to execute
 * @param type - The GraphQL type to resolve the directive for
 * @param constDirectiveOption - The directive configuration options
 * @param fallback - Optional fallback value if resolution fails
 * @returns The resolved directive value or fallback/undefined
 */
const getCustomDirectiveResolver = (resolver, type, constDirectiveOption, fallback) => {
    if (typeof constDirectiveOption === "undefined" ||
        typeof constDirectiveOption.type !== "object" ||
        typeof constDirectiveOption[resolver] !== "function") {
        return fallback;
    }
    return constDirectiveOption[resolver](constDirectiveOption.type, type);
};
exports.getCustomDirectiveResolver = getCustomDirectiveResolver;
/**
 * Prints a custom directive as a Markdown string
 * @param type - The GraphQL type to print the directive for
 * @param constDirectiveOption - The directive configuration options
 * @param options - General printing options
 * @returns Formatted Markdown string for the directive or undefined
 */
const printCustomDirective = (type, constDirectiveOption, options) => {
    const typeNameLink = (0, link_1.printLink)(constDirectiveOption.type, {
        ...options,
        withAttributes: false,
    });
    const description = (0, exports.getCustomDirectiveResolver)("descriptor", type, constDirectiveOption);
    if (typeof description !== "string") {
        return undefined;
    }
    return `${options_1.SectionLevels.LEVEL.repeat(4)} ${typeNameLink}${strings_1.MARKDOWN_EOL} ${description}${strings_1.MARKDOWN_EOL} `;
};
exports.printCustomDirective = printCustomDirective;
/**
 * Prints all custom directives for a type as a Markdown section
 * @param type - The GraphQL type to print directives for
 * @param options - General printing options
 * @returns Markdown string containing all formatted directives
 */
const printCustomDirectives = (type, options) => {
    const constDirectiveMap = (0, graphql_1.getConstDirectiveMap)(type, options.customDirectives);
    if (!constDirectiveMap || Object.keys(constDirectiveMap).length < 1) {
        return "";
    }
    const directives = Object.values(constDirectiveMap)
        .map((constDirectiveOption) => {
        return (0, exports.printCustomDirective)(type, constDirectiveOption, options);
    })
        .filter((value) => {
        return typeof value !== "undefined";
    });
    if (directives.length === 0) {
        return "";
    }
    const content = directives.join(strings_1.MARKDOWN_EOP);
    return `${options_1.SectionLevels.LEVEL.repeat(3)} Directives${strings_1.MARKDOWN_EOP}${content}${strings_1.MARKDOWN_EOP}`;
};
exports.printCustomDirectives = printCustomDirectives;
/**
 * Extracts custom tags from directives for a given type
 * @param type - The GraphQL type to get tags for
 * @param options - General printing options
 * @returns Array of badge configurations from directive tags
 */
const getCustomTags = (type, options) => {
    const constDirectiveMap = (0, graphql_1.getConstDirectiveMap)(type, options.customDirectives);
    if (typeof constDirectiveMap !== "object" ||
        constDirectiveMap === null ||
        !Object.keys(constDirectiveMap).length) {
        return [];
    }
    return Object.values(constDirectiveMap)
        .map((constDirectiveOption) => {
        return (0, exports.getCustomDirectiveResolver)("tag", type, constDirectiveOption);
    })
        .filter((value) => {
        return typeof value !== "undefined";
    });
};
exports.getCustomTags = getCustomTags;
/**
 * Prints custom directive tags as Markdown badges
 * @param type - The GraphQL type to print tags for
 * @param options - General printing options
 * @returns Formatted Markdown string of badges or empty string
 */
const printCustomTags = (type, options) => {
    const badges = (0, exports.getCustomTags)(type, options);
    if (badges.length === 0) {
        return "";
    }
    return badges
        .map((badge) => {
        return (0, badge_1.printBadge)(badge, options);
    })
        .join(" ");
};
exports.printCustomTags = printCustomTags;
