"use strict";
/**
 * Module for handling GraphQL type badges in MDX documentation.
 * Provides functionality to generate and format badges for different GraphQL types
 * and their properties like deprecation status, nullability, and relationships.
 * @module
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.printBadges = exports.printBadge = exports.getTypeBadges = exports.CSS_BADGE_CLASSNAME = void 0;
const utils_1 = require("@graphql-markdown/utils");
const graphql_1 = require("@graphql-markdown/graphql");
const link_1 = require("./link");
const group_1 = require("./group");
const strings_1 = require("./const/strings");
exports.CSS_BADGE_CLASSNAME = {
    DEPRECATED: "DEPRECATED",
    RELATION: "RELATION",
    NON_NULL: "NON_NULL",
};
/**
 * Gets an array of badges for a given GraphQL type.
 * @param type - The GraphQL type to generate badges for
 * @param groups - Optional map of schema entities to their groups
 * @returns Array of Badge objects containing text and optional classnames
 */
const getTypeBadges = (type, groups) => {
    const badges = [];
    if (typeof type !== "object" || type === null) {
        return badges;
    }
    const rootType = ("type" in type ? type.type : type);
    if ((0, graphql_1.isDeprecated)(type)) {
        badges.push({
            text: strings_1.DEPRECATED,
            classname: exports.CSS_BADGE_CLASSNAME.DEPRECATED,
        });
    }
    if ((0, graphql_1.isNonNullType)(rootType)) {
        badges.push({
            text: strings_1.NON_NULL,
            classname: exports.CSS_BADGE_CLASSNAME.NON_NULL,
        });
    }
    if ((0, graphql_1.isListType)(rootType)) {
        badges.push({ text: "list" });
    }
    const category = (0, link_1.getCategoryLocale)((0, graphql_1.getNamedType)(rootType));
    if (category) {
        badges.push({ text: category });
    }
    if (groups) {
        const typeCategory = (typeof category === "string" ? category : category?.plural);
        const group = (0, group_1.getGroup)(rootType, groups, typeCategory);
        if (group && group !== "") {
            badges.push({ text: group });
        }
    }
    return badges;
};
exports.getTypeBadges = getTypeBadges;
/**
 * Formats a single badge into MDX string format.
 * @param badge - The badge object containing text and optional classname
 * @param options - Options for printing/formatting the badge
 * @returns Formatted MDX string representation of the badge
 */
const printBadge = ({ text, classname }, options) => {
    const textString = typeof text === "object" ? text.singular : text;
    const formattedText = (0, utils_1.escapeMDX)(textString);
    return options.formatMDXBadge({
        text: formattedText,
        classname,
    });
};
exports.printBadge = printBadge;
/**
 * Generates and formats all applicable badges for a GraphQL type.
 * @param type - The GraphQL type to generate badges for
 * @param options - Options for printing/formatting the badges
 * @returns Formatted MDX string containing all badges, or empty string if no badges or badges disabled
 */
const printBadges = (type, options) => {
    if (!("typeBadges" in options) ||
        typeof options.typeBadges !== "boolean" ||
        !options.typeBadges) {
        return "";
    }
    const badges = (0, exports.getTypeBadges)(type, options.groups);
    if (badges.length === 0) {
        return "";
    }
    return badges
        .map((badge) => {
        return (0, exports.printBadge)(badge, options);
    })
        .join(" ");
};
exports.printBadges = printBadges;
