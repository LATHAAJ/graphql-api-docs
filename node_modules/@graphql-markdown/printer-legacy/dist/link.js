"use strict";
/**
 * Module for handling links and link-related operations in GraphQL Markdown printer.
 * Provides utilities for creating, formatting, and managing links to GraphQL types and operations.
 * @packageDocumentation
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.printParentLink = exports.printLink = exports.printLinkAttributes = exports.getRelationLink = exports.toLink = exports.getLinkDeprecatedFolder = exports.getLinkApiGroupFolder = exports.hasOptionParentType = exports.hasOptionWithAttributes = exports.getLinkCategoryFolder = exports.getCategoryLocale = exports.hasPrintableDirective = exports.API_GROUPS = void 0;
const graphql_1 = require("@graphql-markdown/graphql");
const utils_1 = require("@graphql-markdown/utils");
const group_1 = require("./group");
const strings_1 = require("./const/strings");
const options_1 = require("./const/options");
exports.API_GROUPS = {
    operations: "operations",
    types: "types",
};
/**
 * Checks if a type has printable directives based on the provided options.
 *
 * @param type - The GraphQL type to check
 * @param options - Configuration options for directive printing
 * @param options.deprecated - How to handle deprecated types
 * @param options.onlyDocDirectives - Only print types with specific directives
 * @param options.skipDocDirectives - Skip types with specific directives
 * @returns `true` if the type should be printed, `false` otherwise
 */
const hasPrintableDirective = (type, options) => {
    if (!type) {
        return false;
    }
    if (!options) {
        return true;
    }
    const skipDirective = "skipDocDirectives" in options && options.skipDocDirectives
        ? (0, graphql_1.hasDirective)(type, options.skipDocDirectives)
        : false;
    const skipDeprecated = "deprecated" in options &&
        options.deprecated === "skip" &&
        (0, graphql_1.isDeprecated)(type);
    const onlyDirective = "onlyDocDirectives" in options && options.onlyDocDirectives
        ? (0, graphql_1.hasDirective)(type, options.onlyDocDirectives, true)
        : true;
    return !(skipDirective || skipDeprecated) && onlyDirective;
};
exports.hasPrintableDirective = hasPrintableDirective;
/**
 * Gets the locale category for a given GraphQL type.
 *
 * @param type - The GraphQL type to get the category for
 * @returns The locale category for the type, or `undefined` if not found
 */
const getCategoryLocale = (type) => {
    switch (true) {
        case (0, graphql_1.isDirectiveType)(type):
            return strings_1.ROOT_TYPE_LOCALE.DIRECTIVE;
        case (0, graphql_1.isEnumType)(type):
            return strings_1.ROOT_TYPE_LOCALE.ENUM;
        case (0, graphql_1.isInputType)(type):
            return strings_1.ROOT_TYPE_LOCALE.INPUT;
        case (0, graphql_1.isInterfaceType)(type):
            return strings_1.ROOT_TYPE_LOCALE.INTERFACE;
        case (0, graphql_1.isObjectType)(type):
            return strings_1.ROOT_TYPE_LOCALE.TYPE;
        case (0, graphql_1.isOperation)(type):
            return strings_1.ROOT_TYPE_LOCALE.OPERATION;
        case (0, graphql_1.isScalarType)(type):
            return strings_1.ROOT_TYPE_LOCALE.SCALAR;
        case (0, graphql_1.isUnionType)(type):
            return strings_1.ROOT_TYPE_LOCALE.UNION;
    }
    return undefined;
};
exports.getCategoryLocale = getCategoryLocale;
/**
 * Gets the folder name for a link category based on the GraphQL type and operation locale.
 *
 * @param type - The GraphQL type to get the folder name for
 * @param operationLocale - The locale of the operation
 * @returns The folder name for the link category, or `undefined` if not found
 */
const getLinkCategoryFolder = (type, operationLocale) => {
    const categoryLocale = (0, exports.getCategoryLocale)(type);
    if (!categoryLocale) {
        return undefined;
    }
    // special case for relation map
    if (categoryLocale === strings_1.ROOT_TYPE_LOCALE.OPERATION) {
        if (!operationLocale) {
            return undefined;
        }
        return typeof operationLocale === "object"
            ? operationLocale.plural
            : operationLocale;
    }
    return typeof categoryLocale === "object"
        ? categoryLocale.plural
        : categoryLocale;
};
exports.getLinkCategoryFolder = getLinkCategoryFolder;
/**
 * Checks if the options include the `withAttributes` attribute.
 *
 * @param options - The options to check
 * @returns `true` if the options include `withAttributes`, `false` otherwise
 */
const hasOptionWithAttributes = (options) => {
    return "withAttributes" in options && options.withAttributes === true;
};
exports.hasOptionWithAttributes = hasOptionWithAttributes;
/**
 * Checks if the options include the `parentTypePrefix` attribute.
 *
 * @param options - The options to check
 * @returns `true` if the options include `parentTypePrefix`, `false` otherwise
 */
const hasOptionParentType = (options) => {
    return ("parentTypePrefix" in options &&
        options.parentTypePrefix === true &&
        "parentType" in options &&
        typeof options.parentType !== "undefined");
};
exports.hasOptionParentType = hasOptionParentType;
/**
 * Gets the folder name for an API group based on the GraphQL type and group options.
 *
 * @param type - The GraphQL type to get the folder name for
 * @param groups - The group options
 * @returns The folder name for the API group
 */
const getLinkApiGroupFolder = (type, groups) => {
    let folderNames = exports.API_GROUPS;
    if (groups && typeof groups === "object") {
        folderNames = { ...exports.API_GROUPS, ...groups };
    }
    return (0, graphql_1.isApiType)(type) ? folderNames.operations : folderNames.types;
};
exports.getLinkApiGroupFolder = getLinkApiGroupFolder;
/**
 * Gets the folder name for deprecated types based on the GraphQL type and deprecation option.
 *
 * @param type - The GraphQL type to get the folder name for
 * @param option - The deprecation option
 * @returns The folder name for deprecated types
 */
const getLinkDeprecatedFolder = (type, option) => {
    return option === "group" && (0, graphql_1.isDeprecated)(type) ? strings_1.DEPRECATED : "";
};
exports.getLinkDeprecatedFolder = getLinkDeprecatedFolder;
const isHierarchy = (options, hierarchy) => {
    return (options?.hierarchy?.[hierarchy] && true);
};
/**
 * Converts a GraphQL type to a link object.
 *
 * @param type - The GraphQL type to convert
 * @param name - The name of the type
 * @param operation - The locale of the operation
 * @param options - Configuration options for link generation
 * @returns The link object for the type
 */
const toLink = (type, name, operation, options) => {
    const fallback = {
        text: name,
        url: "#",
    };
    if (typeof type !== "object" ||
        (typeof options !== "undefined" && !(0, exports.hasPrintableDirective)(type, options))) {
        return fallback;
    }
    const graphQLNamedType = (0, graphql_1.getNamedType)(type);
    if (!graphQLNamedType) {
        return fallback;
    }
    let category = "";
    let deprecatedFolder = "";
    let groupFolder = "";
    let apiGroupFolder = "";
    if (!isHierarchy(options, options_1.TypeHierarchy.FLAT)) {
        category = (0, exports.getLinkCategoryFolder)(graphQLNamedType, operation);
        if (!category) {
            return fallback;
        }
        deprecatedFolder = options.deprecated
            ? (0, exports.getLinkDeprecatedFolder)(type, options.deprecated)
            : "";
        groupFolder = options.groups
            ? (0, group_1.getGroup)(type, options.groups, category)
            : "";
        apiGroupFolder = isHierarchy(options, options_1.TypeHierarchy.API)
            ? (0, exports.getLinkApiGroupFolder)(type)
            : "";
    }
    const text = graphQLNamedType.name || graphQLNamedType.toString();
    const url = utils_1.pathUrl.join(options.basePath, deprecatedFolder, apiGroupFolder, groupFolder, category, `${(0, utils_1.slugify)(text)}`);
    const link = {
        text,
        url,
    };
    if (options.formatMDXLink) {
        return options.formatMDXLink(link);
    }
    return link;
};
exports.toLink = toLink;
/**
 * Gets the link for a relation based on the category, type, and options.
 *
 * @param category - The locale category of the relation
 * @param type - The GraphQL type of the relation
 * @param options - Configuration options for link generation
 * @returns The link object for the relation, or `undefined` if not found
 */
const getRelationLink = (category, type, options) => {
    if (!category ||
        typeof type !== "object" ||
        type === null ||
        !("name" in type)) {
        return undefined;
    }
    return (0, exports.toLink)(type, type.name, category, options);
};
exports.getRelationLink = getRelationLink;
/**
 * Prints the attributes of a link based on the GraphQL type.
 *
 * @param type - The GraphQL type to print attributes for
 * @param text - The text to append attributes to
 * @returns The text with appended attributes
 */
const printLinkAttributes = (type, text = "") => {
    if (typeof type !== "object" || type === null) {
        return text ?? "";
    }
    if (!(0, graphql_1.isLeafType)(type) &&
        "ofType" in type &&
        typeof type.ofType !== "undefined") {
        text = (0, exports.printLinkAttributes)(type.ofType, text);
    }
    if ((0, graphql_1.isListType)(type)) {
        return `[${text}]`;
    }
    if ((0, graphql_1.isNonNullType)(type)) {
        return `${text}!`;
    }
    return text ?? "";
};
exports.printLinkAttributes = printLinkAttributes;
/**
 * Prints a link for a GraphQL type based on the provided options.
 *
 * @param type - The GraphQL type to print a link for
 * @param options - Configuration options for link generation
 * @returns The formatted link as a string
 */
const printLink = (type, options) => {
    if (typeof type !== "object" || type === null) {
        return "";
    }
    const link = (0, exports.toLink)(type, (0, graphql_1.getTypeName)(type, (0, utils_1.toString)(type)), undefined, options);
    if (typeof options !== "undefined" && !(0, exports.hasOptionWithAttributes)(options)) {
        const textWithAttribute = options.formatMDXNameEntity(link.text, options.parentType);
        return `[${textWithAttribute}](${link.url})`;
    }
    const text = (0, exports.printLinkAttributes)(type, link.text);
    return `[${options.formatMDXNameEntity(text)}](${link.url})`;
};
exports.printLink = printLink;
/**
 * Prints a parent link for a GraphQL type based on the provided options.
 *
 * @param type - The GraphQL type to print a parent link for
 * @param options - Configuration options for link generation
 * @returns The formatted parent link as a string or MDX string
 */
const printParentLink = (type, options) => {
    if (typeof type !== "object" || type === null || !("type" in type)) {
        return "";
    }
    return options.formatMDXBullet((0, exports.printLink)(type.type, {
        ...options,
        withAttributes: true,
    }));
};
exports.printParentLink = printParentLink;
