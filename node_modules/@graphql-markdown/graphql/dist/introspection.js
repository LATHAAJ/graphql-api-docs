"use strict";
/**
 * Library for introspecting a GraphQL schema.
 * The entry point method is {@link getSchemaMap}.
 *
 * @packageDocumentation
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.getSchemaMap = exports.getTypeName = exports.getFields = exports.getOperation = exports._getFields = exports.getTypeDirectiveArgValue = exports.getTypeDirectiveValues = exports.getDirective = exports.hasDirective = exports.isValidDirectiveLocation = exports.getDirectiveLocationForASTPath = exports.hasAstNode = exports.getTypeFromSchema = exports.IntrospectionError = exports.parse = exports.GraphQLSchema = exports.getNullableType = exports.getNamedType = exports.printSchema = void 0;
const type_1 = require("graphql/type");
const language_1 = require("graphql/language");
const execution_1 = require("graphql/execution");
const utils_1 = require("@graphql-markdown/utils");
const guard_1 = require("./guard");
var utilities_1 = require("graphql/utilities");
Object.defineProperty(exports, "printSchema", { enumerable: true, get: function () { return utilities_1.printSchema; } });
var type_2 = require("graphql/type");
Object.defineProperty(exports, "getNamedType", { enumerable: true, get: function () { return type_2.getNamedType; } });
Object.defineProperty(exports, "getNullableType", { enumerable: true, get: function () { return type_2.getNullableType; } });
Object.defineProperty(exports, "GraphQLSchema", { enumerable: true, get: function () { return type_2.GraphQLSchema; } });
var language_2 = require("graphql/language");
Object.defineProperty(exports, "parse", { enumerable: true, get: function () { return language_2.parse; } });
Object.defineProperty(exports, "print", { enumerable: true, get: function () { return language_2.print; } });
/**
 *
 * @example
 */
class IntrospectionError extends Error {
}
exports.IntrospectionError = IntrospectionError;
/**
 * Returns a map of GraphQL named types from a schema for a defined GraphQL type.
 * When parsing the entities, internal GraphQL entities (starting with `__`) are excluded.
 *
 * @see {@link getSchemaMap}
 *
 * @internal
 *
 * @param schema - a GraphQL schema.
 * @param type - a GraphQL type, eg `GraphQLObjectType`.
 *
 * @returns a map of GraphQL named types for the matching GraphQL type, or undefined if no match.
 *
 */
const getTypeFromSchema = (schema, type) => {
    if (!schema) {
        return undefined;
    }
    const operationKinds = [];
    Object.values(language_1.OperationTypeNode).forEach((operationTypeNode) => {
        const operationType = schema.getRootType(operationTypeNode);
        if (operationType) {
            operationKinds.push(operationType.name);
        }
    });
    const filterOperationFragmentRegExp = operationKinds.length > 0 ? [...operationKinds, ""].join("$|") : "";
    const excludeListRegExp = new RegExp(`^(?!${filterOperationFragmentRegExp}__.+$).*$`);
    const typeMap = schema.getTypeMap();
    return Object.keys(typeMap)
        .filter((key) => {
        return excludeListRegExp.test(key);
    })
        .filter((key) => {
        return (0, guard_1.instanceOf)(typeMap[key], type);
    })
        .reduce((res, key) => {
        return { ...res, [key]: typeMap[key] };
    }, {});
};
exports.getTypeFromSchema = getTypeFromSchema;
/**
 * Type guard for type with an AST node property.
 *
 * @internal
 *
 * @param node - a GraphQL schema named type.
 *
 * @returns `true` if the entity has an AST node property, else `false`.
 *
 */
const hasAstNode = (node) => {
    return typeof node["astNode"] === "object";
};
exports.hasAstNode = hasAstNode;
/**
 *
 */
const getDirectiveLocationForASTPath = (appliedTo) => {
    if (!appliedTo || !("kind" in appliedTo)) {
        throw new IntrospectionError("Unexpected kind: " + String(appliedTo));
    }
    switch (appliedTo.kind) {
        case language_1.Kind.FIELD:
            return language_1.DirectiveLocation.FIELD;
        case language_1.Kind.SCHEMA_DEFINITION:
        case language_1.Kind.SCHEMA_EXTENSION:
            return language_1.DirectiveLocation.SCHEMA;
        case language_1.Kind.SCALAR_TYPE_DEFINITION:
        case language_1.Kind.SCALAR_TYPE_EXTENSION:
            return language_1.DirectiveLocation.SCALAR;
        case language_1.Kind.OBJECT_TYPE_DEFINITION:
        case language_1.Kind.OBJECT_TYPE_EXTENSION:
            return language_1.DirectiveLocation.OBJECT;
        case language_1.Kind.FIELD_DEFINITION:
            return language_1.DirectiveLocation.FIELD_DEFINITION;
        case language_1.Kind.INTERFACE_TYPE_DEFINITION:
        case language_1.Kind.INTERFACE_TYPE_EXTENSION:
            return language_1.DirectiveLocation.INTERFACE;
        case language_1.Kind.UNION_TYPE_DEFINITION:
        case language_1.Kind.UNION_TYPE_EXTENSION:
            return language_1.DirectiveLocation.UNION;
        case language_1.Kind.ENUM_TYPE_DEFINITION:
        case language_1.Kind.ENUM_TYPE_EXTENSION:
            return language_1.DirectiveLocation.ENUM;
        case language_1.Kind.ENUM_VALUE_DEFINITION:
            return language_1.DirectiveLocation.ENUM_VALUE;
        case language_1.Kind.INPUT_OBJECT_TYPE_DEFINITION:
        case language_1.Kind.INPUT_OBJECT_TYPE_EXTENSION:
            return language_1.DirectiveLocation.INPUT_OBJECT;
        case language_1.Kind.INPUT_VALUE_DEFINITION:
        case language_1.Kind.ARGUMENT:
            return language_1.DirectiveLocation.ARGUMENT_DEFINITION;
        // Not reachable, all possible types have been considered.
        default:
            throw new IntrospectionError("Unexpected kind: " + String(appliedTo.kind));
    }
};
exports.getDirectiveLocationForASTPath = getDirectiveLocationForASTPath;
/** Check if a directive can be applied to specific schema entity location.
 *
 * @param entity - a GraphQL schema entity.
 * @param directive - a directive name.
 *
 * @returns `true` if the entity is a valid directive location, else `false`.
 *
 */
const isValidDirectiveLocation = (entity, directive) => {
    if (!(0, exports.hasAstNode)(entity)) {
        return false;
    }
    const location = (0, exports.getDirectiveLocationForASTPath)(entity.astNode);
    return directive.locations.includes(location);
};
exports.isValidDirectiveLocation = isValidDirectiveLocation;
/**
 * Checks if a schema entity as a directive belonging to a defined set.
 *
 * @param entity - a GraphQL schema entity.
 * @param directives - a directive name or a list of directive names.
 * @param fallback - default value if the entity type is not a valid location for directives.
 *
 * @returns `true` if the entity has at least one directive matching, else `false`.
 *
 */
const hasDirective = (entity, directives, fallback = false) => {
    if (!(0, exports.hasAstNode)(entity) ||
        !directives ||
        !Array.isArray(entity.astNode.directives) ||
        directives.length < 1) {
        return fallback;
    }
    return (directives.findIndex((directive) => {
        // if the directive location is not applicable to entity then skip it
        if (!(0, exports.isValidDirectiveLocation)(entity, directive)) {
            return fallback;
        }
        return (entity.astNode.directives &&
            entity.astNode.directives.findIndex((directiveNode) => {
                return directive.name === directiveNode.name.value;
            }) > -1);
    }) > -1);
};
exports.hasDirective = hasDirective;
/**
 * Returns a schema entity's list of directives matching a defined set.
 *
 * @param entity - a GraphQL schema entity.
 * @param directives - a directive name or a list of directive names.
 *
 * @returns a list of GraphQL directives matching the set, else `false`.
 *
 */
const getDirective = (entity, directives) => {
    if (!(0, exports.hasAstNode)(entity) ||
        !directives ||
        !Array.isArray(entity.astNode.directives)) {
        return [];
    }
    return directives.filter((directive) => {
        return ((entity.astNode.directives &&
            entity.astNode.directives.findIndex((directiveNode) => {
                return directiveNode.name.value === directive.name;
            }) > -1) ??
            false);
    });
};
exports.getDirective = getDirective;
/**
 * Returns all directive's arguments' values linked to a GraphQL schema type.
 *
 * @param directive - a GraphQL directive defined in the schema.
 * @param type - the GraphQL schema type to parse.
 *
 * @returns a record k/v with arguments' name as keys and arguments' value.
 *
 */
const getTypeDirectiveValues = (directive, type) => {
    if ((0, exports.hasAstNode)(type)) {
        return (0, execution_1.getDirectiveValues)(directive, type.astNode);
    }
    return (0, execution_1.getDirectiveValues)(directive, type);
};
exports.getTypeDirectiveValues = getTypeDirectiveValues;
/**
 * Returns one directive's argument's value linked to a GraphQL schema type.
 * It calls {@link getTypeDirectiveValues} and returns a matching record.
 *
 * @param directive - a GraphQL directive defined in the schema.
 * @param type - the GraphQL schema type to parse.
 * @param argName - the name of the GraphQL directive argument to fetch the value from.
 *
 * @returns a record k/v with `argName` as key and the argument's value.
 *
 */
const getTypeDirectiveArgValue = (directive, node, argName) => {
    const args = (0, exports.getTypeDirectiveValues)(directive, node);
    if (!args?.[argName]) {
        throw new IntrospectionError(`Directive argument '${argName}' not found!`);
    }
    return args[argName];
};
exports.getTypeDirectiveArgValue = getTypeDirectiveArgValue;
/**
 * Returns the fields from a GraphQL schema type.
 *
 * @internal
 *
 * see {@link getOperation}, {@link getFields}
 *
 * @param type - the GraphQL schema type to parse.
 * @param processor - optional callback function to parse the fields map.
 * @param fallback - optional fallback value, `undefined` if not set.
 *
 * @returns a map of fields as k/v records, or `fallback` value if no fields available.
 *
 */
const _getFields = (type, 
/**
 * @param fieldMap - a field map to be processed.
 * @returns a new field map.
 */
processor, fallback) => {
    if (!(typeof type === "object" &&
        type !== null &&
        "getFields" in type &&
        (0, type_1.isNamedType)(type))) {
        return fallback;
    }
    const fieldMap = type.getFields();
    if (typeof processor === "function") {
        return processor(fieldMap);
    }
    return fieldMap;
};
exports._getFields = _getFields;
/**
 * Returns fields map for a GraphQL operation type (query, mutation, subscription...).
 *
 * @internal
 *
 * see {@link getSchemaMap}
 *
 * @param operationType - the operation type to parse.
 *
 * @returns a map of fields as k/v records.
 *
 */
const getOperation = (operationType) => {
    return (0, exports._getFields)(operationType, (fieldMap) => {
        return Object.keys(fieldMap).reduce((res, key) => {
            return { ...res, [key]: fieldMap[key] };
        }, {});
    }, {});
};
exports.getOperation = getOperation;
/**
 * Returns fields map for a GraphQL schema type.
 *
 * see {@link getSchemaMap}
 *
 * @param type - the GraphQL schema type to parse.
 *
 * @returns a list of fields of type object.
 *
 */
const getFields = (type) => {
    return (0, exports._getFields)(type, (fieldMap) => {
        const res = [];
        Object.keys(fieldMap).forEach((name) => {
            return res.push(fieldMap[name]);
        });
        return res;
    }, []);
};
exports.getFields = getFields;
/**
 * Resolves the name of a GraphQL schema type.
 *
 * @param getTypeName - the GraphQL schema type to parse.
 * @param defaultName - optional fallback value if the name resolution fails.
 *
 * @returns the type's name, or `defaultName`.
 *
 */
const getTypeName = (type, defaultName = "") => {
    if (!(typeof type === "object" && type !== null)) {
        return defaultName;
    }
    if ("name" in type) {
        return (0, utils_1.toString)(type.name);
    }
    if ("toString" in type && typeof type.toString === "function") {
        return (0, utils_1.toString)(type);
    }
    return defaultName;
};
exports.getTypeName = getTypeName;
/**
 * Returns an introspection map of the GraphQL schema.
 * This is the entry point for GraphQL-Markdown schema parsing features.
 *
 * @param schema - a GraphQL schema.
 *
 * @returns a schema map by GraphQL entities (see {@link SchemaEntity}).
 *
 * @example
 * ```js
 * import { buildSchema } from "graphql";
 * import { getSchemaMap } from "@graphql-markdown/utils/graphql";
 *
 * const schema = buildSchema(`
 *   interface Record {
 *     id: String!
 *   }
 *   type StudyItem implements Record {
 *     id: String!
 *     subject: String!
 *     duration: Int!
 *   }
 *   type Query {
 *     getStudyItems(subject: String): [StudyItem!]
 *     getStudyItem(id: String!): StudyItem
 *   }
 *   type Mutation {
 *     addStudyItem(subject: String!, duration: Int!): StudyItem
 *   }
 *   type Subscription {
 *     listStudyItems: [StudyItem!]
 *   }
 * `);
 *
 * const schemaTypeMap = getSchemaMap(schema);
 *
 * // expected result: {
 * //   queries: {
 * //     getStudyItems: GraphQLField,
 * //     getStudyItem: GraphQLField,
 * //   },
 * //   mutations: {
 * //     addStudyItem: GraphQLField,
 * //   },
 * //   subscriptions: {
 * //     listStudyItems: GraphQLField,
 * //   }
 * //   directives: {
 * //     include: GraphQLDirective,
 * //     skip: GraphQLDirective,
 * //     deprecated: GraphQLDirective,
 * //     specifiedBy: GraphQLDirective,
 * //   objects: {
 * //     StudyItem: GraphQLObjectType,
 * //   unions: {},
 * //   interfaces: {
 * //     Record: GraphQLInterfaceType,
 * //   enums: {},
 * //   inputs: {},
 * //   scalars: {
 * //     String: GraphQLScalarType,
 * //     Int: GraphQLScalarType,
 * //     Boolean: GraphQLScalarType,
 * //   }
 * // }
 * ```
 *
 */
const getSchemaMap = (schema) => {
    return {
        ["queries"]: (0, exports.getOperation)(schema?.getQueryType() ?? undefined),
        ["mutations"]: (0, exports.getOperation)(schema?.getMutationType() ?? undefined),
        ["subscriptions"]: (0, exports.getOperation)(schema?.getSubscriptionType() ?? undefined),
        ["directives"]: (0, utils_1.convertArrayToMapObject)(schema?.getDirectives()),
        ["objects"]: (0, exports.getTypeFromSchema)(schema, type_1.GraphQLObjectType),
        ["unions"]: (0, exports.getTypeFromSchema)(schema, type_1.GraphQLUnionType),
        ["interfaces"]: (0, exports.getTypeFromSchema)(schema, type_1.GraphQLInterfaceType),
        ["enums"]: (0, exports.getTypeFromSchema)(schema, type_1.GraphQLEnumType),
        ["inputs"]: (0, exports.getTypeFromSchema)(schema, type_1.GraphQLInputObjectType),
        ["scalars"]: (0, exports.getTypeFromSchema)(schema, type_1.GraphQLScalarType),
    };
};
exports.getSchemaMap = getSchemaMap;
