"use strict";
/**
 * Custom GraphQL type guards and property guards.
 *
 * @packageDocumentation
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.isSystemType = exports.isApiType = exports.typeSystemDirectiveLocation = exports.executableDirectiveLocation = exports.isOperation = exports.isDeprecated = exports.instanceOf = exports.isGraphQLFieldType = exports.isNode = exports.isUnionType = exports.isType = exports.isScalarType = exports.isObjectType = exports.isNonNullType = exports.isNamedType = exports.isListType = exports.isLeafType = exports.isInterfaceType = exports.isInputType = exports.isEnumType = exports.isDirectiveType = void 0;
const language_1 = require("graphql/language");
const directives_1 = require("graphql/type/directives");
var type_1 = require("graphql/type");
Object.defineProperty(exports, "isDirectiveType", { enumerable: true, get: function () { return type_1.isDirective; } });
Object.defineProperty(exports, "isEnumType", { enumerable: true, get: function () { return type_1.isEnumType; } });
Object.defineProperty(exports, "isInputType", { enumerable: true, get: function () { return type_1.isInputObjectType; } });
Object.defineProperty(exports, "isInterfaceType", { enumerable: true, get: function () { return type_1.isInterfaceType; } });
Object.defineProperty(exports, "isLeafType", { enumerable: true, get: function () { return type_1.isLeafType; } });
Object.defineProperty(exports, "isListType", { enumerable: true, get: function () { return type_1.isListType; } });
Object.defineProperty(exports, "isNamedType", { enumerable: true, get: function () { return type_1.isNamedType; } });
Object.defineProperty(exports, "isNonNullType", { enumerable: true, get: function () { return type_1.isNonNullType; } });
Object.defineProperty(exports, "isObjectType", { enumerable: true, get: function () { return type_1.isObjectType; } });
Object.defineProperty(exports, "isScalarType", { enumerable: true, get: function () { return type_1.isScalarType; } });
Object.defineProperty(exports, "isType", { enumerable: true, get: function () { return type_1.isType; } });
Object.defineProperty(exports, "isUnionType", { enumerable: true, get: function () { return type_1.isUnionType; } });
var ast_1 = require("graphql/language/ast");
Object.defineProperty(exports, "isNode", { enumerable: true, get: function () { return ast_1.isNode; } });
/**
 * Checks if a GraphQL named type is of type `GraphQLField`.
 *
 * @param type - a GraphQL type.
 *
 */
const isGraphQLFieldType = (type) => {
    return (typeof type === "object" &&
        type !== null &&
        "args" in type &&
        type.args.length > 0);
};
exports.isGraphQLFieldType = isGraphQLFieldType;
/**
 * Checks if a GraphQL named type is of generic type `T`.
 *
 * @typeParam T - a GraphQL type to check against, eg `GraphQLObjectType`.
 * @param obj - a GraphQL named type from the GraphQL schema.
 * @param type - the GraphQL type `T`.
 *
 */
const instanceOf = (obj, type) => {
    try {
        const expect = type.name;
        return typeof obj !== "object" || obj === null
            ? false
            : obj.constructor.name === expect;
    }
    catch {
        return false;
    }
};
exports.instanceOf = instanceOf;
/**
 * Checks if a GraphQL named type is deprecated.
 *
 * @typeParam T - a GraphQL type to check against, eg `GraphQLObjectType`.
 * @param obj - an instance of `T`.
 *
 */
const isDeprecated = (obj) => {
    return (typeof obj === "object" &&
        obj !== null &&
        (("isDeprecated" in obj && obj.isDeprecated === true) ||
            ("deprecationReason" in obj && typeof obj.deprecationReason === "string")));
};
exports.isDeprecated = isDeprecated;
/**
 * Checks if a GraphQL type a GraphQL operation (query, mutation, subscription).
 *
 * @param type - a GraphQL type.
 *
 */
const isOperation = (type) => {
    return typeof type === "object" && type !== null && "type" in type;
};
exports.isOperation = isOperation;
/**
 * Checks if a directive is executable (related to operations).
 *
 * @param type - a GraphQL directive.
 *
 */
const executableDirectiveLocation = (directive) => {
    return [
        language_1.DirectiveLocation.QUERY,
        language_1.DirectiveLocation.MUTATION,
        language_1.DirectiveLocation.SUBSCRIPTION,
        language_1.DirectiveLocation.FIELD,
        language_1.DirectiveLocation.FRAGMENT_DEFINITION,
        language_1.DirectiveLocation.FRAGMENT_SPREAD,
        language_1.DirectiveLocation.INLINE_FRAGMENT,
        language_1.DirectiveLocation.VARIABLE_DEFINITION,
    ].some((item) => {
        return directive.locations.includes(item);
    });
};
exports.executableDirectiveLocation = executableDirectiveLocation;
/**
 * Checks if a directive is system (related to schema definition).
 *
 * @param type - a GraphQL directive.
 *
 */
const typeSystemDirectiveLocation = (directive) => {
    // we assume that if not executable then it is a system directive
    return !(0, exports.executableDirectiveLocation)(directive);
};
exports.typeSystemDirectiveLocation = typeSystemDirectiveLocation;
/**
 * Checks if a type belongs to API (operation related).
 *
 * @param type - a GraphQL type.
 *
 */
const isApiType = (type) => {
    if ((0, exports.isOperation)(type)) {
        return true;
    }
    return (0, directives_1.isDirective)(type) && (0, exports.executableDirectiveLocation)(type);
};
exports.isApiType = isApiType;
/**
 * Checks if a type belongs to schema (schema type definition excluding operations related types).
 *
 * @param type - a GraphQL type.
 *
 */
const isSystemType = (type) => {
    return !(0, exports.isApiType)(type);
};
exports.isSystemType = isSystemType;
