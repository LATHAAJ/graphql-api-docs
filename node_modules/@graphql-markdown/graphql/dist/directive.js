"use strict";
/**
 * Library supporting `customDirective` for directive based customization.
 *
 * @see [Option `customDirective`](https://graphql-markdown.dev/docs/advanced/custom-directive)
 *
 * @packageDocumentation
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.getConstDirectiveMap = exports.getCustomDirectives = exports.getCustomDirectiveOptions = exports.isCustomDirective = exports.WILDCARD_DIRECTIVE = void 0;
const utils_1 = require("@graphql-markdown/utils");
const introspection_1 = require("./introspection");
/**
 * Wildcard `*` character for matching any directive name.
 *
 * See {@link getCustomDirectiveOptions}, {@link isCustomDirective}
 *
 */
exports.WILDCARD_DIRECTIVE = "*";
/**
 * Checks if a directive name is referenced in `customDirective` option.
 *
 * @param schemaDirectiveName - the GraphQL directive name.
 * @param customDirectiveOptions - the `customDirective` option.
 *
 * @returns `true` if the directive is declared or `*` is declared in `customDirective` option, else `false`.
 *
 */
const isCustomDirective = (schemaDirectiveName, customDirectiveOptions) => {
    return (schemaDirectiveName in customDirectiveOptions ||
        exports.WILDCARD_DIRECTIVE in customDirectiveOptions);
};
exports.isCustomDirective = isCustomDirective;
/**
 * Returns a record set of custom handlers from a directive by name.
 *
 * @param schemaDirectiveName - the GraphQL directive name.
 * @param customDirectiveOptions - the `customDirective` option.
 *
 * @returns a record set of custom handlers for the matching directive (or if `*` is declared), or undefined if no match.
 *
 * @example
 * ```js
 * import { getCustomDirectiveOptions } from "@graphql-markdown/utils/directive";
 *
 * const customDirectiveOptions = {
 *   "*": {
 *     descriptor: (_, constDirectiveType) => `Wildcard ${constDirectiveType.name}`;
 *   },
 * };
 *
 * const customDirectives = getCustomDirectiveOptions("testB", customDirectiveOptions);
 *
 * // Expected result: {
 * //   "descriptor": (_, constDirectiveType) => `Wildcard ${constDirectiveType.name}`,
 * //   "type": "@testB",
 * // }
 * ```
 *
 */
const getCustomDirectiveOptions = (schemaDirectiveName, customDirectiveOptions) => {
    if (schemaDirectiveName in customDirectiveOptions) {
        return customDirectiveOptions[schemaDirectiveName];
    }
    if (exports.WILDCARD_DIRECTIVE in customDirectiveOptions) {
        return customDirectiveOptions[exports.WILDCARD_DIRECTIVE];
    }
    return undefined;
};
exports.getCustomDirectiveOptions = getCustomDirectiveOptions;
/**
 * Returns a custom directives map with custom handlers from `customDirective`.
 *
 * @param schemaMap - the GraphQL schema map returned by {@link introspection!getSchemaMap}
 * @param customDirectiveOptions - the `customDirective` option.
 *
 * @returns a custom directive map, or undefined if no match.
 *
 * @example
 * ```js
 * import { buildSchema } from "graphql";
 * import { getCustomDirectives } from "@graphql-markdown/utils/directive";
 *
 * const schema = buildSchema(`
 *   directive @testA(
 *     arg: ArgEnum = ARGA
 *   ) on OBJECT | FIELD_DEFINITION
 *   directive @testB(
 *     argA: Int!,
 *     argB: [String!]
 *   ) on FIELD_DEFINITION
 *   enum ArgEnum {
 *     ARGA
 *     ARGB
 *     ARGC
 *   }
 * `);
 *
 * const schemaMap = {
 *   directives: {
 *     testA: schema.getDirective("testA"),
 *     testB: schema.getDirective("testB"),
 *   },
 * };
 *
 * const customDirectiveOptions = {
 *   testA: {
 *     descriptor: (_, constDirectiveType) => `Named directive ${constDirectiveType.name}`;
 *   },
 *   "*": {
 *     descriptor: (_, constDirectiveType) => `Wildcard ${constDirectiveType.name}`;
 *   },
 * };
 *
 * const customDirectives = getCustomDirectives(schemaMap, customDirectiveOptions);
 *
 * // Expected result: {
 * //   "testA": {
 * //     "descriptor": (_, constDirectiveType) => `Named directive ${constDirectiveType.name}`,
 * //     "type": "@testA",
 * //   },
 * //   "testB": {
 * //     "descriptor": (_, constDirectiveType) => `Wildcard ${constDirectiveType.name}`,
 * //     "type": "@testB",
 * //   },
 * // }
 * ```
 *
 */
const getCustomDirectives = ({ directives: schemaDirectives }, customDirectiveOptions) => {
    const customDirectives = {};
    if (!customDirectiveOptions ||
        typeof schemaDirectives !== "object" ||
        typeof customDirectiveOptions !== "object") {
        return undefined;
    }
    for (const schemaDirectiveName in schemaDirectives) {
        if (!(0, exports.isCustomDirective)(schemaDirectiveName, customDirectiveOptions)) {
            continue;
        }
        const directiveOptions = (0, exports.getCustomDirectiveOptions)(schemaDirectiveName, customDirectiveOptions);
        if (typeof directiveOptions !== "object") {
            continue;
        }
        customDirectives[schemaDirectiveName] = {
            type: schemaDirectives[schemaDirectiveName],
            ...directiveOptions,
        };
    }
    return (0, utils_1.isEmpty)(customDirectives) ? undefined : customDirectives;
};
exports.getCustomDirectives = getCustomDirectives;
/**
 * Returns a map of custom directives for a schema entity.
 *
 * @param entity - a GraphQL schema entity.
 * @param customDirectiveMap - a custom directive map (see {@link getCustomDirectives}).
 *
 * @returns a map of GraphQL directives matching the custom directives defined, else `undefined`.
 *
 * @example
 * ```js
 * import { buildSchema } from "graphql";
 * import { getConstDirectiveMap } from "@graphql-markdown/utils/directive";
 *
 * const schema = buildSchema(`
 *     directive @testA(
 *       arg: ArgEnum = ARGA
 *     ) on OBJECT | FIELD_DEFINITION
 *
 *     directive @testB(
 *       argA: Int!,
 *       argB: [String!]
 *     ) on FIELD_DEFINITION
 *
 *     enum ArgEnum {
 *       ARGA
 *       ARGB
 *       ARGC
 *     }
 *
 *     type Test @testA {
 *       id: ID!
 *       fieldA: [String!]
 *         @testA(arg: ARGC)
 *         @testB(argA: 10, argB: ["testArgB"])
 *     }
 *
 *     type TestWithoutDirective {
 *       id: ID!
 *     }
 *   `);
 *
 * const customDirectives = {
 *   testA: {
 *     type: schema.getDirective("testA"),
 *     descriptor: (_, constDirectiveType) => `${constDirectiveType.name}`;
 *   },
 * };
 *
 * const map = getConstDirectiveMap(schema.getType("Test"), customDirectives);
 * // Expected result: {
 * //   "descriptor": (_, constDirectiveType) => `${constDirectiveType.name}`,
 * //   "type": schema.getDirective("testA"),
 * // }
 *
 * ```
 */
const getConstDirectiveMap = (entity, customDirectiveMap) => {
    if ((0, utils_1.isEmpty)(customDirectiveMap)) {
        return undefined;
    }
    const directiveList = Object.values(customDirectiveMap).map((directiveMapItem) => {
        return directiveMapItem.type;
    });
    const constDirectives = (0, introspection_1.getDirective)(entity, directiveList);
    if (constDirectives.length === 0) {
        return undefined;
    }
    return constDirectives.reduce((directiveMap, constDirective) => {
        const name = constDirective.name;
        directiveMap[name] = customDirectiveMap[name];
        return directiveMap;
    }, {});
};
exports.getConstDirectiveMap = getConstDirectiveMap;
