"use strict";
/**
 * Library supporting `relatedTypeSection` for displaying relations between GraphQL schema entities.
 *
 * @see [Option `relatedTypeSection`](https://graphql-markdown.dev/docs/settings#printtypeoptions)
 *
 * @packageDocumentation
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.getRelationOfImplementation = exports.getRelationOfInterface = exports.getRelationOfUnion = exports.getRelationOfField = exports.getRelationOfReturn = void 0;
const graphql_1 = require("graphql");
const utils_1 = require("@graphql-markdown/utils");
const introspection_1 = require("./introspection");
const guard_1 = require("./guard");
/**
 * Generic method for fetching relations for a given GraphQL schema type.
 *
 * @internal
 *
 * @typeParam T - the type of the relation.
 *
 * @param type - the GraphQL schema type being processed.
 * @param relations - the map of relations to be returned.
 * @param schemaMap - a GraphQL schema map (see {@link introspection!getSchemaMap}).
 * @param callback - a function to execute for each entries of the schema map.
 *
 * @returns a record map of type `relations`.
 *
 */
const mapRelationOf = (type, relations, schemaMap, callback) => {
    if (!schemaMap) {
        return {};
    }
    for (const relation of Object.keys(relations)) {
        const entity = schemaMap[relation];
        if (!entity) {
            continue;
        }
        let results = [];
        for (const [relationName, relationType] of Object.entries(entity)) {
            results = callback(type, relationName, relationType, results);
        }
        relations[relation] = results;
    }
    return relations;
};
/**
 * Returns a map of operations (queries, mutations, subscriptions) where the GraphQL schema type is the return type.
 *
 * @see {@link mapRelationOf}
 *
 * @typeParam T - the type of the GraphQL schema type.
 * @typeParam R - the return type of map of relations (see {@link IGetRelation}).
 *
 * @param type - the GraphQL schema type being processed.
 * @param schemaMap - a GraphQL schema map (see {@link introspection!getSchemaMap}).
 *
 * @returns a record map of operations relations.
 *
 */
const getRelationOfReturn = (type, schemaMap) => {
    const relations = {
        queries: [],
        mutations: [],
        subscriptions: [],
    };
    const parserCallback = (type, relationName, relationType, results) => {
        if (typeof relationType === "object" &&
            (0, graphql_1.isNamedType)(type) &&
            "type" in relationType &&
            (0, graphql_1.getNamedType)(relationType.type)?.name ===
                type.name) {
            if (!results.find((r) => {
                return (typeof r === "object" &&
                    r !== null &&
                    "name" in r &&
                    r.name === relationName);
            })) {
                results.push(relationType);
            }
        }
        return results;
    };
    return mapRelationOf(type, relations, schemaMap, parserCallback);
};
exports.getRelationOfReturn = getRelationOfReturn;
/**
 * Returns a map of fields and arguments where the GraphQL schema type matches the type.
 *
 * @see {@link mapRelationOf}
 *
 * @typeParam T - the type of the GraphQL schema type.
 * @typeParam R - the return type of map of relations (see {@link IGetRelation}).
 *
 * @param type - the GraphQL schema type being processed.
 * @param schemaMap - a GraphQL schema map (see {@link introspection!getSchemaMap}).
 *
 * @returns a record map of fields and arguments relations.
 *
 */
const getRelationOfField = (type, schemaMap) => {
    const relations = {
        queries: [],
        mutations: [],
        subscriptions: [],
        objects: [],
        interfaces: [],
        inputs: [],
        directives: [],
    };
    const parserCallback = (type, relationName, relationType, results) => {
        // directives are handled as flat array instead of map
        const key = (0, graphql_1.isDirective)(relationType)
            ? relationType.name
            : relationName;
        const paramFieldArgs = (0, guard_1.isGraphQLFieldType)(relationType)
            ? relationType.args
            : {};
        const fieldMap = (0, introspection_1._getFields)(relationType, undefined, {});
        const fields = Object.assign({}, paramFieldArgs, fieldMap);
        for (const fieldDef of Object.values(fields)) {
            if ((0, graphql_1.isNamedType)(type) &&
                (0, graphql_1.getNamedType)(fieldDef.type)?.name === type.name) {
                if (!results.find((r) => {
                    return ((0, utils_1.toString)(r) === key ||
                        (typeof r === "object" && "name" in r && r.name === key));
                })) {
                    results.push(relationType);
                }
            }
        }
        return results;
    };
    return mapRelationOf(type, relations, schemaMap, parserCallback);
};
exports.getRelationOfField = getRelationOfField;
/**
 * Returns a map of unions where the GraphQL schema type is part of it.
 *
 * @see {@link mapRelationOf}
 *
 * @typeParam T - the type of the GraphQL schema type.
 * @typeParam R - the return type of map of relations (see {@link IGetRelation}).
 *
 * @param type - the GraphQL schema type being processed.
 * @param schemaMap - a GraphQL schema map (see {@link introspection!getSchemaMap}).
 *
 * @returns a record map of unions relations.
 *
 */
const getRelationOfUnion = (type, schemaMap) => {
    const relations = {
        unions: [],
    };
    const parserCallback = (type, relationName, relationType, results) => {
        if ((0, graphql_1.isNamedType)(type) &&
            (0, graphql_1.isUnionType)(relationType) &&
            relationType.getTypes().find((subType) => {
                return subType.name === type.name;
            })) {
            if (!results.find((r) => {
                return (typeof r === "object" && "name" in r && r.name === relationName);
            })) {
                results.push(relationType);
            }
        }
        return results;
    };
    return mapRelationOf(type, relations, schemaMap, parserCallback);
};
exports.getRelationOfUnion = getRelationOfUnion;
/**
 * Returns a map of interfaces where the GraphQL schema type is extended.
 *
 * @see {@link mapRelationOf}
 *
 * @typeParam T - the type of the GraphQL schema type.
 * @typeParam R - the return type of map of relations (see {@link IGetRelation}).
 *
 * @param type - the GraphQL schema type being processed.
 * @param schemaMap - a GraphQL schema map (see {@link introspection!getSchemaMap}).
 *
 * @returns a record map of interfaces relations.
 *
 */
const getRelationOfInterface = (type, schemaMap) => {
    const relations = {
        objects: [],
        interfaces: [],
    };
    const parserCallback = (type, relationName, relationType, results) => {
        if ((0, graphql_1.isNamedType)(type) &&
            ((0, graphql_1.isObjectType)(relationType) || (0, graphql_1.isInterfaceType)(relationType)) &&
            relationType.getInterfaces().find((subType) => {
                return subType.name === type.name;
            })) {
            if (!results.find((r) => {
                return (typeof r === "object" && "name" in r && r.name === relationName);
            })) {
                results.push(relationType);
            }
        }
        return results;
    };
    return mapRelationOf(type, relations, schemaMap, parserCallback);
};
exports.getRelationOfInterface = getRelationOfInterface;
/**
 * Returns a map of types (unions or interfaces) where the GraphQL schema type is implemented.
 *
 * @see {@link mapRelationOf}
 *
 * @typeParam T - the type of the GraphQL schema type.
 * @typeParam R - the return type of map of relations (see {@link IGetRelation}).
 *
 * @param type - the GraphQL schema type being processed.
 * @param schemaMap - a GraphQL schema map (see {@link introspection!getSchemaMap}).
 *
 * @returns a record map of unions or interfaces relations.
 *
 */
const getRelationOfImplementation = (type, schemaMap) => {
    return {
        ...(0, exports.getRelationOfInterface)(type, schemaMap),
        ...(0, exports.getRelationOfUnion)(type, schemaMap),
    };
};
exports.getRelationOfImplementation = getRelationOfImplementation;
